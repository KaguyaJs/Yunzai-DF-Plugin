import t from"node:fs";import e from"node:fs/promises";import r from"node:path";import s from"lodash";import{YunzaiPath as i,PluginPath as a,ResPath as n}from"../dir.js";import{createHash as c}from"node:crypto";export function getRoot(t="plugin"){switch(t){case"root":case"yunzai":return`${i}/`;case"res":case"assets":return`${n}/`;case"json":return`${n}/json`;default:return`${a}/`}}function o(t,e="plugin"){return r.isAbsolute(t)?t:r.resolve(getRoot(e),t)}export class Data{static JSONCache=new Map;static createDir(e="",s="plugin",i=!1){const a=o(e,s),n=i?r.dirname(a):a;t.existsSync(n)||t.mkdirSync(n,{recursive:!0})}static getJSON(e,r="plugin",s=!0){const i=o(e,r);if(s&&this.JSONCache.has(i))return this.JSONCache.get(i);if(!t.existsSync(i))return{};try{const e=JSON.parse(t.readFileSync(i,"utf8"));return s&&this.JSONCache.set(i,e),e}catch(t){return logger.error("读取 JSON 文件错误",t),{}}}static async readJSON(t,r="plugin"){const s=o(t,r);try{const t=await e.readFile(s,"utf8");return JSON.parse(t)}catch{return{}}}static async writeJSON(t,r,s="plugin",i=2){const a=o(t,s);try{return this.createDir(a,s,!0),await e.writeFile(a,JSON.stringify(r,null,i)),this.JSONCache.set(a,r),!0}catch(t){return logger.error(t),!1}}static async getRedisJSON(t){try{const e=await redis.get(t);return e?JSON.parse(e):{}}catch(t){return logger.error(t),{}}}static async setRedisJSON(t,e,r=7776e3){await redis.set(t,JSON.stringify(e),{EX:r})}static async importModule(e,r="plugin"){const s=o(e.endsWith(".js")?e:`${e}.js`,r);if(!t.existsSync(s))return{};try{return await import(`file://${s}?t=${Date.now()}`)??{}}catch(t){return logger.error(t),{}}}static async importDefault(t,e){return(await this.importModule(t,e)).default??{}}static readDirRecursive(e,s,i){const a=o(e),n=t.readdirSync(a,{withFileTypes:!0}),c=[];for(const t of n){const e=r.join(a,t.name);if(t.isDirectory()){if(t.name===i)continue;const a=this.readDirRecursive(e,s,i);c.push(...a.map(e=>r.join(t.name,e)))}else r.extname(t.name)===`.${s}`&&c.push(t.name)}return c}static async asyncPool(t,e,r){const s=[],i=[];for(const a of e){const n=Promise.resolve().then(()=>r(a,e));if(s.push(n),t<=e.length){const e=n.finally(()=>i.splice(i.indexOf(e),1));i.push(e),i.length>=t&&await Promise.race(i)}}return Promise.all(s)}static sleep(t){return new Promise(e=>setTimeout(e,t))}static def(...t){return t.find(t=>!s.isUndefined(t))}static eachStr(t,e){let r;r="string"==typeof t?t.replace(/\s*(;|；|、|，)\s*/g,",").split(","):"number"==typeof t?[t.toString()]:t,r.forEach((t,r)=>e(t.trim?.()??t,r))}static regRet(t,e,r){const s=t.exec(e);return s?.[r]??!1}static async exists(r){try{return await e.access(r,t.constants.F_OK),!0}catch{return!1}}static async isDirectory(t){try{return(await e.stat(t)).isDirectory()}catch{return!1}}static stableStringify(t,e=new WeakMap){if(null===t||"object"!=typeof t)return JSON.stringify(t);if(e.has(t))return e.get(t);let r;if(Array.isArray(t))r="["+t.map(t=>this.stableStringify(t,e)).join(",")+"]";else{r="{"+Object.keys(t).sort().map(r=>`"${r}":${this.stableStringify(t[r],e)}`).join(",")+"}"}return e.set(t,r),r}static getSetKey(t){const e=Array.from(t),r=new WeakMap,s=e.map(t=>this.stableStringify(t,r));return s.sort((t,e)=>t.localeCompare(e)),c("sha256").update(JSON.stringify(s)).digest("hex")}}export default Data;